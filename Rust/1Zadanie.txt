use std::collections::HashMap;
use std::io;

// Функция для вычисления минимального количества операций
fn min_operations(input_string: &str) -> usize {
    // Длина входной строки
    let n = input_string.len();
    // Вектор для хранения минимального количества операций для каждого индекса
    let mut dp = vec![0; n + 1];
    // Хэш-карта для хранения последнего вхождения каждого символа
    let mut last_occurrence = HashMap::new();

    // Проходим по каждому символу входной строки
    for i in 1..=n {
        // Инициализируем dp[i] как dp[i-1] + 1, предполагая, что необходимо добавить один символ
        dp[i] = dp[i - 1] + 1;

        // Если последнее вхождение текущего символа существует в хэш-карте
        if let Some(&idx) = last_occurrence.get(&input_string.chars().nth(i - 1).unwrap()) {
            // Обновляем dp[i] как минимум между текущим dp[i] и dp послед-него вхождения символа + 1
            dp[i] = dp[i].min(dp[idx] + 1);
        }

        // Обновляем хэш-карту последнего вхождения текущего символа
        last_occurrence.insert(input_string.chars().nth(i - 1).unwrap(), i);
    }

    // Возвращаем минимальное количество операций для всей строки
    dp[n]
}

fn main() {
    // Выводим приглашение пользователю ввести строку
    println!("Введите строку:");
    // Создаем переменную для хранения введенной строки
    let mut input_string = String::new();
    // Читаем строку из стандартного ввода
    io::stdin().read_line(&mut input_string).expect("Не удалось прочитать строку");
    // Удаляем лишние пробелы и символы новой строки из введенной стро-ки
    let input_string = input_string.trim();

    // Вызываем функцию min_operations и выводим результат
    println!("Минимальное количество операций: {}", min_operations(input_string));
}
